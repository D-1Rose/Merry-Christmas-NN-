<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas, NN!</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Times New Roman', serif; }
        
        #ui-container {
            position: absolute; bottom: 40px; width: 100%; text-align: center; 
            pointer-events: none; z-index: 10;
        }
        
        #greeting {
            font-size: 3.5em; 
            font-weight: 100;
            color: #fff;
            /* 黄金色的辉光文字 */
            text-shadow: 0 0 10px #ffaa00, 0 0 20px #ffaa00, 0 0 40px #ffaa00;
            pointer-events: auto; display: inline-block;
            font-style: italic;
            letter-spacing: 2px;
        }
        
        #sub-text {
            font-size: 1em; color: #ccaa88; margin-top: 10px; font-family: sans-serif;
            text-transform: uppercase; letter-spacing: 4px; opacity: 0.8;
        }

        /* 加载遮罩 */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #050510; z-index: 999;
            display: flex; justify-content: center; align-items: center;
            color: #ccaa88; font-family: sans-serif; letter-spacing: 2px;
            transition: opacity 1s ease;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/tween.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
</head>
<body>

    <div id="loader">正在布置圣诞场景...</div>

    <div id="ui-container">
        <div id="greeting" contenteditable="true">Merry Christmas, NN!</div>
        <div id="sub-text">Winter Memories</div>
    </div>

    <script>
        // --- 1. 配置 ---
        // 你的本地图片
        const imageFiles = ['./1.jpg', './2.jpg', './3.jpg']; 
        
        let scene, camera, renderer, composer, controls;
        let clock = new THREE.Clock();

        // 颜色配置 (暖色调)
        const COLORS = {
            background: 0x1a0b2e, // 深紫色夜空
            ground: 0xffffff,
            lightWarm: 0xffaa00,  // 暖光
            lightCold: 0x4444ff,  // 冷光补光
            treeGreen: 0x0d2b15   // 深绿松叶
        };

        function init() {
            // 场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.background);
            // 暖色雾气，营造梦幻感
            scene.fog = new THREE.FogExp2(COLORS.background, 0.002);

            // 相机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 40, 180);

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping; // 电影级色调映射
            document.body.appendChild(renderer.domElement);

            // 控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; // 禁止钻入地下

            // --- 2. 灯光系统 ---
            // 环境光
            scene.add(new THREE.AmbientLight(0x404040, 1));
            
            // 树心暖光 (核心光源)
            const pointLight = new THREE.PointLight(COLORS.lightWarm, 2, 300);
            pointLight.position.set(0, 50, 0);
            scene.add(pointLight);

            // 模拟月光 (冷色轮廓光)
            const moonLight = new THREE.DirectionalLight(COLORS.lightCold, 0.5);
            moonLight.position.set(-50, 100, 50);
            scene.add(moonLight);

            // --- 3. 环境搭建 ---
            createGround();
            createSnow();

            // --- 4. 圣诞树 ---
            createTreeTrunk();
            createPineNeedles(); // 高质量松针
            createOrnaments();   // 发光装饰球
            createHangingPhotos(); // 照片

            // --- 5. 后期处理 (Bloom 特效) ---
            initPostProcessing();

            // 移除 Loading
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 1000);

            animate();
        }

        // --- 核心特效：辉光 (Bloom) ---
        function initPostProcessing() {
            const renderScene = new THREE.RenderPass(scene, camera);

            // Unreal Bloom 参数：分辨率, 强度, 半径, 阈值
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5,  // Strength (发光强度)
                0.4,  // Radius (发光半径)
                0.85  // Threshold (只有超过这个亮度的物体才会发光)
            );

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
        }

        // --- 创建反光雪地 ---
        function createGround() {
            const geometry = new THREE.PlaneGeometry(1000, 1000);
            const material = new THREE.MeshStandardMaterial({
                color: COLORS.ground,
                roughness: 0.1, // 光滑一点，产生倒影
                metalness: 0.1
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -20;
            scene.add(ground);
        }

        // --- 创建树干 ---
        function createTreeTrunk() {
            const geometry = new THREE.CylinderGeometry(2, 8, 150, 16);
            const material = new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.9 });
            const trunk = new THREE.Mesh(geometry, material);
            trunk.position.y = 55;
            scene.add(trunk);
        }

        // --- 创建松针 (InstancedMesh 高性能渲染) ---
        function createPineNeedles() {
            const count = 8000; // 8000根松针
            // 使用细长的四面体模拟松针
            const geometry = new THREE.TetrahedronGeometry(1.5, 0);
            geometry.applyMatrix4(new THREE.Matrix4().makeScale(1, 4, 1));
            
            const material = new THREE.MeshStandardMaterial({
                color: COLORS.treeGreen,
                roughness: 0.8
            });

            const mesh = new THREE.InstancedMesh(geometry, material, count);
            const dummy = new THREE.Object3D();

            for (let i = 0; i < count; i++) {
                const y = Math.random() * 140; // 高度分布
                const progress = 1 - (y / 140);
                const radius = (10 + progress * 50) * Math.sqrt(Math.random()); // 圆锥分布
                const angle = Math.random() * Math.PI * 2;

                dummy.position.set(
                    Math.cos(angle) * radius,
                    y,
                    Math.sin(angle) * radius
                );
                
                // 让松针随机朝向，并稍微向下垂
                dummy.lookAt(0, y, 0);
                dummy.rotation.x += Math.random() * 0.5; 

                dummy.scale.setScalar(1 + Math.random());
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            mesh.position.y = -10; // 调整整体高度
            scene.add(mesh);
        }

        // --- 创建发光装饰球 ---
        function createOrnaments() {
            const count = 300;
            const geometry = new THREE.SphereGeometry(1.5, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: 0xffcc00,
                emissive: 0xffaa00, // 自发光
                emissiveIntensity: 2, // 强度高一点，配合 Bloom
                roughness: 0.1,
                metalness: 0.8
            });

            const mesh = new THREE.InstancedMesh(geometry, material, count);
            const dummy = new THREE.Object3D();

            for (let i = 0; i < count; i++) {
                const y = Math.random() * 130;
                const progress = 1 - (y / 130);
                const radius = (12 + progress * 48); // 只在表面
                const angle = Math.random() * Math.PI * 2;

                dummy.position.set(
                    Math.cos(angle) * radius,
                    y - 5,
                    Math.sin(angle) * radius
                );
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            }
            scene.add(mesh);
        }

        // --- 创建照片 ---
        function createHangingPhotos() {
            const loader = new THREE.TextureLoader();
            const geometry = new THREE.PlaneGeometry(14, 18);
            const group = new THREE.Group();

            for (let i = 0; i < 30; i++) {
                const y = (i / 30) * 120 + 10;
                const progress = 1 - (y / 140);
                const radius = 25 + progress * 40; 
                const angle = i * 0.5; // 螺旋排列

                // 材质：稍微发光，让照片在夜里清晰可见
                const material = new THREE.MeshBasicMaterial({
                    side: THREE.DoubleSide
                });

                const photo = new THREE.Mesh(geometry, material);
                
                // 位置
                photo.position.set(
                    Math.cos(angle) * radius,
                    y,
                    Math.sin(angle) * radius
                );
                
                // 朝向外侧
                photo.lookAt(0, y, 0);
                photo.rotateY(Math.PI); // 翻转一下，否则图片可能反了

                // 随机摆动参数
                photo.userData = {
                    randomPhase: Math.random() * Math.PI * 2,
                    originalY: y
                };

                // 加载图片
                loader.load(imageFiles[i % imageFiles.length], (tex) => {
                    photo.material.map = tex;
                    photo.material.needsUpdate = true;
                });

                group.add(photo);
            }
            // 保存这个组以便在动画里旋转
            scene.add(group);
            window.photoGroup = group;
        }

        // --- 创建柔和雪花 ---
        function createSnow() {
            // 生成圆形渐变纹理，而不是方块
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.CanvasTexture(canvas);

            const geometry = new THREE.BufferGeometry();
            const count = 2000;
            const positions = [];
            const velocities = [];

            for(let i=0; i<count; i++) {
                positions.push(
                    (Math.random()-0.5)*400,
                    Math.random()*200,
                    (Math.random()-0.5)*400
                );
                velocities.push(
                    (Math.random()-0.5) * 0.2, // x
                    -(Math.random() * 0.5 + 0.2), // y 下落
                    (Math.random()-0.5) * 0.2  // z
                );
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                map: texture,
                size: 2,
                transparent: true,
                opacity: 0.8,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            const snow = new THREE.Points(geometry, material);
            snow.userData = { velocities: velocities };
            scene.add(snow);
            window.snowSystem = snow;
        }

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            controls.update();

            // 1. 照片轻微摆动
            if (window.photoGroup) {
                window.photoGroup.children.forEach(photo => {
                    photo.position.y = photo.userData.originalY + Math.sin(time * 2 + photo.userData.randomPhase) * 1.5;
                    photo.rotation.z = Math.sin(time + photo.userData.randomPhase) * 0.1;
                });
            }

            // 2. 雪花下落
            if (window.snowSystem) {
                const positions = window.snowSystem.geometry.attributes.position.array;
                const vels = window.snowSystem.userData.velocities;
                
                for(let i=0; i<2000; i++) {
                    positions[i*3] += vels[i*3];     // x
                    positions[i*3+1] += vels[i*3+1]; // y
                    positions[i*3+2] += vels[i*3+2]; // z

                    // 循环
                    if(positions[i*3+1] < -20) {
                        positions[i*3+1] = 200;
                        positions[i*3] = (Math.random()-0.5)*400;
                        positions[i*3+2] = (Math.random()-0.5)*400;
                    }
                }
                window.snowSystem.geometry.attributes.position.needsUpdate = true;
                window.snowSystem.rotation.y = time * 0.05; // 雪花整体旋转
            }

            // 使用 EffectComposer 渲染 (替代 renderer.render)
            composer.render();
        }

        // 窗口适配
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>