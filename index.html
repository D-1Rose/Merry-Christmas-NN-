<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyberpunk Christmas</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        
        /* 霓虹风格 UI */
        #ui-container {
            position: absolute; bottom: 30px; width: 100%; text-align: center; 
            pointer-events: none; z-index: 10;
        }
        #greeting {
            font-size: 3em; 
            font-family: 'Courier New', monospace; /* 更有科技感 */
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 40px #00ffff;
            pointer-events: auto; display: inline-block;
            animation: pulseText 3s infinite alternate;
        }
        #status {
            font-size: 0.9em; color: #00ffaa; margin-top: 10px;
            background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 4px; display: inline-block;
        }
        
        /* 隐藏原始视频流，我们只需要数据 */
        .input_video { display: none; }

        @keyframes pulseText {
            from { text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff; }
            to { text-shadow: 0 0 20px #ff00de, 0 0 40px #ff00de; }
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="greeting" contenteditable="true">Merry Christmas, NN!</div>
        <br>
        <div id="status">正在连接神经网络... (请允许摄像头权限)</div>
    </div>

    <video class="input_video"></video>

    <script src="./three.js"></script>
    <script src="./OrbitControls.js"></script>
    <script src="./tween.js"></script>

    <script>
        // --- 1. 配置与全局变量 ---
        const imageFiles = ['./1.jpg', './2.jpg', './3.jpg']; // 你的本地图片
        
        let scene, camera, renderer, controls;
        let particleSystem, photoGroup;
        let handControlActive = false; // 是否检测到手
        let isPinching = false; // 是否在捏合

        const statusDiv = document.getElementById('status');
        
        // 粒子配置
        const particleCount = 15000; // 粒子数量
        const treeHeight = 200;
        const baseRadius = 60;

        // --- 2. 场景初始化 ---
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002); // 黑色迷雾

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 80, 200);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;

            // 创建内容
            createParticleTree();
            createFloatingPhotos();
            createEtherealLights();
            
            // 启动 MediaPipe
            setupMediaPipe();
            
            animate();
        }

        // --- 3. 粒子圣诞树 (核心视觉) ---
        function createParticleTree() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            const speeds = []; // 粒子闪烁速度

            const colorPalette = [
                new THREE.Color('#ffcc00'), // 金色
                new THREE.Color('#00ffff'), // 赛博蓝
                new THREE.Color('#ff00de'), // 霓虹紫
                new THREE.Color('#ffffff')  // 白光
            ];

            for (let i = 0; i < particleCount; i++) {
                // 螺旋算法
                const y = Math.random() * treeHeight;
                const progress = 1 - (y / treeHeight);
                const radius = (baseRadius * progress) + (Math.random() * 5); // 稍微离散一点
                
                // 黄金角度螺旋分布
                const angle = i * 0.5 + (y * 0.05); 
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                positions.push(x, y - 50, z); // y轴偏移让树底居中

                // 颜色随机
                const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                colors.push(color.r, color.g, color.b);

                sizes.push(Math.random() * 1.5);
                speeds.push(Math.random());
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('speed', new THREE.Float32BufferAttribute(speeds, 1));

            // 自定义着色器材质（让粒子发光、变色）
            // 这里为了简化代码，使用带贴图的 PointsMaterial 配合 AdditiveBlending
            const texture = createGlowTexture();
            const material = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                map: texture,
                blending: THREE.AdditiveBlending, // 关键：颜色叠加发光
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        // --- 4. 悬浮照片 ---
        function createFloatingPhotos() {
            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            const loader = new THREE.TextureLoader();
            const geometry = new THREE.PlaneGeometry(12, 18); // 照片尺寸

            for (let i = 0; i < 40; i++) {
                const y = Math.random() * (treeHeight - 20);
                const progress = 1 - (y / treeHeight);
                const radius = (baseRadius * progress) + 15; // 浮在树表面外面一点
                const angle = Math.random() * Math.PI * 2;

                const material = new THREE.MeshBasicMaterial({
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending 
                });

                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(
                    Math.cos(angle) * radius,
                    y - 50,
                    Math.sin(angle) * radius
                );
                
                // 让照片始终朝向中心稍偏上，像悬浮卡片
                mesh.lookAt(0, y - 50, 0);
                
                // 随机动画参数
                mesh.userData = {
                    randomOffset: Math.random() * 100,
                    speed: 0.01 + Math.random() * 0.02
                };

                // 加载图片
                loader.load(imageFiles[i % imageFiles.length], (tex) => {
                    mesh.material.map = tex;
                    mesh.material.needsUpdate = true;
                });

                photoGroup.add(mesh);
            }
        }

        // --- 5. 辅助光效 ---
        function createEtherealLights() {
            // 底部蓝光
            const bottomLight = new THREE.PointLight(0x00ffff, 2, 300);
            bottomLight.position.set(0, -50, 0);
            scene.add(bottomLight);
            
            // 顶部紫光
            const topLight = new THREE.PointLight(0xff00de, 2, 300);
            topLight.position.set(0, 150, 0);
            scene.add(topLight);
        }

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- 6. MediaPipe 手势识别逻辑 ---
        function setupMediaPipe() {
            const videoElement = document.getElementsByClassName('input_video')[0];
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            cameraUtils.start()
                .then(() => {
                    statusDiv.innerText = "视觉连接成功！伸出手掌控制旋转，捏合手指触发特效";
                    statusDiv.style.color = "#00ffaa";
                })
                .catch(err => {
                    statusDiv.innerText = "未检测到摄像头，已切换至自动演示模式";
                    statusDiv.style.color = "#ffaa00";
                });
        }

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handControlActive = true;
                controls.autoRotate = false; // 停止自动旋转，接管控制
                
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. 获取手掌中心 (大约是 9 号点)
                const handX = landmarks[9].x; // 0-1, 左-右
                const handY = landmarks[9].y; // 0-1, 上-下

                // 映射到相机旋转
                // 手在左边(0) -> 相机左转; 手在右边(1) -> 相机右转
                const targetAngle = (handX - 0.5) * Math.PI * 4; // 放大旋转范围
                const targetY = (handY - 0.5) * 200 + 80;

                // 平滑过渡相机位置
                const radius = 200;
                const camX = Math.sin(targetAngle) * radius;
                const camZ = Math.cos(targetAngle) * radius;
                
                // 使用 TWEEN 平滑移动相机
                new TWEEN.Tween(camera.position)
                    .to({ x: camX, y: targetY + 50, z: camZ }, 200)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();

                camera.lookAt(0, 80, 0);

                // 2. 检测捏合 (食指尖 8 和 拇指尖 4 的距离)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                if (distance < 0.05) { // 阈值，小于这个距离算捏合
                    if (!isPinching) {
                        triggerExplosion(); // 触发一次特效
                    }
                    isPinching = true;
                } else {
                    isPinching = false;
                }

            } else {
                handControlActive = false;
                controls.autoRotate = true; // 恢复自动旋转
            }
        }

        function triggerExplosion() {
            // 捏合时的特效：粒子颜色爆发变成红色/紫色
            const colors = particleSystem.geometry.attributes.color;
            for(let i=0; i<particleCount; i++) {
                if (Math.random() > 0.5) {
                    colors.setXYZ(i, 2.0, 0.2, 0.5); // 高亮红粉色
                }
            }
            colors.needsUpdate = true;
            
            // 1秒后恢复
            setTimeout(() => {
                const colorPalette = [
                    new THREE.Color('#ffcc00'), new THREE.Color('#00ffff'), 
                    new THREE.Color('#ff00de'), new THREE.Color('#ffffff')
                ];
                for(let i=0; i<particleCount; i++) {
                    const c = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                    colors.setXYZ(i, c.r, c.g, c.b);
                }
                colors.needsUpdate = true;
            }, 1000);
        }

        // --- 7. 动画循环 ---
        const clock = new THREE.Clock();

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            
            // 如果没有手势控制，就用默认的 OrbitControls
            if (!handControlActive) {
                controls.update();
            }

            const elapsed = clock.getElapsedTime();

            // 粒子呼吸动画
            const positions = particleSystem.geometry.attributes.position.array;
            for(let i=0; i < particleCount; i++) {
                // 让粒子轻微上下浮动
                positions[i*3 + 1] += Math.sin(elapsed + positions[i*3]) * 0.1;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;

            // 整个粒子系统缓慢自转
            particleSystem.rotation.y = elapsed * 0.05;

            // 照片悬浮动画
            photoGroup.children.forEach(photo => {
                photo.position.y += Math.sin(elapsed * 2 + photo.userData.randomOffset) * 0.05;
                // 让照片永远朝向摄像机 (Billboard)
                photo.lookAt(camera.position);
            });

            renderer.render(scene, camera);
        }

        // 窗口适配
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 初始化
        init();

    </script>
</body>
</html>