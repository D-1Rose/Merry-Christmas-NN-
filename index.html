<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas, NN!</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Times New Roman', serif; /* æ¢å›è¡¬çº¿ä½“ï¼Œæ›´æ˜¾é«˜çº§ */
            /* æ·±é‚ƒçš„æ˜Ÿç©ºæ¸å˜èƒŒæ™¯ */
            background: radial-gradient(circle at center bottom, #3b1c31 0%, #1a0b2e 60%, #000000 100%);
        }
        
        #ui-container {
            position: absolute; bottom: 30px; width: 100%; text-align: center; 
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        
        #greeting {
            font-size: 3.5em; 
            font-weight: 100;
            color: #fff;
            /* é‡‘è‰²è¾‰å…‰ï¼Œé«˜çº§æ„Ÿ */
            text-shadow: 0 0 10px #ffaa00, 0 0 20px #ff6600, 0 0 40px #ff0000;
            pointer-events: auto;
            margin-bottom: 25px;
            font-style: italic;
            letter-spacing: 2px;
            animation: floatText 3s infinite ease-in-out;
        }
        
        #slider-container {
            pointer-events: auto;
            background: rgba(20, 10, 30, 0.6); 
            padding: 12px 25px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            display: flex; align-items: center; gap: 15px;
            color: #ffccaa; font-size: 1em; 
            border: 1px solid rgba(255, 200, 100, 0.2);
            box-shadow: 0 0 15px rgba(255, 100, 50, 0.2);
        }

        input[type=range] {
            width: 180px; cursor: pointer; accent-color: #ffaa00;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); text-shadow: 0 0 10px #ffaa00, 0 0 20px #ff6600; }
            50% { transform: translateY(-5px); text-shadow: 0 0 15px #ffcc00, 0 0 30px #ff8800; }
        }

        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050510; z-index: 999;
            display: flex; justify-content: center; align-items: center;
            color: #ccaa88; font-size: 1.2em; letter-spacing: 2px;
            transition: opacity 1s ease;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/tween.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
</head>
<body>

    <div id="loading">âœ¨ æ­£åœ¨å¸ƒç½®æ¢¦å¹»åœºæ™¯...</div>

    <div id="ui-container">
        <div id="greeting" contenteditable="true">Merry Christmas, NN!</div>
        
        <div id="slider-container">
            <span>ğŸŒ™ é™è°§</span>
            <input type="range" id="brightnessSlider" min="0.5" max="2.5" step="0.1" value="1.3">
            <span>âœ¨ ç’€ç’¨</span>
        </div>
    </div>

    <script>
        // --- 1. é…ç½®åŒºåŸŸ ---
        const imageFiles = ['./1.jpg', './2.jpg', './3.jpg', './4.jpg', './5.jpg']; 
        const EMOJIS = ['ğŸ', 'ğŸ¦Œ', 'ğŸ¬', 'ğŸ””', 'â„ï¸', 'â›„', 'ğŸ„', 'ğŸŒŸ'];

        let scene, camera, renderer, composer, controls;
        let particleTree, lights = [], topStar;
        let bloomPass;
        
        window.photoCards = new THREE.Group();
        window.stars = new THREE.Group();

        function init() {
            // åœºæ™¯
            scene = new THREE.Scene();
            // é›¾æ°”ï¼šä½¿ç”¨æ·±ç´«è‰²ï¼Œè¥é€ å¤œæ™šçºµæ·±æ„Ÿ
            scene.fog = new THREE.FogExp2(0x1a0b2e, 0.0015); 

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 50, 190);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // å…³é”®ï¼šä½¿ç”¨ LinearToneMapping ä¿æŒå…‰æ„Ÿï¼Œä½†é€šè¿‡ exposure æ§åˆ¶äº®åº¦
            renderer.toneMapping = THREE.LinearToneMapping; 
            renderer.toneMappingExposure = 1.0; 
            document.body.appendChild(renderer.domElement);

            // æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.6; // ç¨å¾®æ…¢ä¸€ç‚¹ï¼Œæ›´ä¼˜é›…
            controls.maxPolarAngle = Math.PI / 2 - 0.05; // åˆšå¥½åœ¨åœ°é¢ä¹‹ä¸Š

            // --- 2. æ¢¦å¹»ç¯å…‰ç³»ç»Ÿ ---
            // ç¯å¢ƒå…‰ï¼šè°ƒä½ï¼Œè®©ç‰©ç†æè´¨çš„é˜´å½±æ˜¾ç°å‡ºæ¥
            const ambientLight = new THREE.AmbientLight(0xccaaee, 0.5); 
            scene.add(ambientLight);
            lights.push(ambientLight);

            // æ ‘å¿ƒæš–å…‰ï¼šç…§äº®æ ‘å¶å†…éƒ¨
            const mainLight = new THREE.PointLight(0xffaa00, 2.0, 400); 
            mainLight.position.set(0, 80, 0);
            scene.add(mainLight);
            lights.push(mainLight);

            // è½®å»“å…‰ï¼šè“è‰²å†·å…‰ï¼Œå‹¾å‹’è¾¹ç¼˜
            const rimLight = new THREE.DirectionalLight(0x4444ff, 0.8);
            rimLight.position.set(-50, 50, 100);
            scene.add(rimLight);
            lights.push(rimLight);

            // --- 3. åœºæ™¯æ­å»º ---
            createStarrySky();   // æ˜Ÿç©º
            createReflectiveGround(); // åœ°é¢
            createFluffyTree();  // åœ£è¯æ ‘
            createTopStar();     // æ ‘é¡¶å¤§æ˜Ÿæ˜Ÿ (æ–°å¢)
            addDecorations();    // Emoji
            addFeaturedPhotos(); // ç‰©ç†æè´¨ç…§ç‰‡
            
            scene.add(window.photoCards);

            // --- 4. åæœŸå¤„ç† (Bloom) ---
            const renderScene = new THREE.RenderPass(scene, camera);
            
            // Bloom å‚æ•°ä¼˜åŒ–ï¼šé˜ˆå€¼è°ƒé«˜ï¼Œé˜²æ­¢å…¨å±æ³›ç™½ï¼Œåªè®©é«˜å…‰ç‰©ä½“å‘å…‰
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.3, // å¼ºåº¦
                0.5, // åŠå¾„
                0.7  // é˜ˆå€¼
            );
            
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç§»é™¤ Loading
            const loader = document.getElementById('loading');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 1000);
            
            // æ»‘å—é€»è¾‘
            const slider = document.getElementById('brightnessSlider');
            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                
                // æ›å…‰åº¦æ§åˆ¶æ•´ä½“æ˜æš—
                renderer.toneMappingExposure = val * 0.8;
                
                // ç¯å…‰éšä¹‹å¢å¼º
                mainLight.intensity = val * 1.5;
                
                // è¾‰å…‰å¼ºåº¦
                bloomPass.strength = val * 0.9;
                
                // æ ‘é¡¶æ˜Ÿæ˜Ÿä¹Ÿä¼šå˜äº®
                if(topStar) topStar.material.emissiveIntensity = val * 1.5;
            });

            animate();
        }

        // --- 1. æ˜Ÿç©ºèƒŒæ™¯ ---
        function createStarrySky() {
            const geometry = new THREE.BufferGeometry();
            const count = 3000;
            const positions = [];
            
            for(let i=0; i<count; i++) {
                const r = 400 + Math.random() * 400; // è¿œå¤„çš„çƒé¢ä¸Š
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                
                positions.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1.5,
                transparent: true,
                opacity: 0.8
            });
            
            const starSystem = new THREE.Points(geometry, material);
            window.stars = starSystem;
            scene.add(starSystem);
        }

        // --- 2. åå…‰åœ°é¢ ---
        function createReflectiveGround() {
            const geometry = new THREE.PlaneGeometry(2000, 2000);
            // ç‰©ç†æè´¨ï¼šé»‘è‰²ï¼Œå…‰æ»‘ï¼Œæœ‰åå…‰
            const material = new THREE.MeshStandardMaterial({
                color: 0x050510,
                roughness: 0.4, 
                metalness: 0.2
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -20; // æ ‘åº•ä¸‹
            scene.add(ground);
        }

        // --- 3. æ ‘é¡¶å¤§æ˜Ÿæ˜Ÿ ---
        function createTopStar() {
            // å…«é¢ä½“ï¼Œåƒä¸€é¢—é’»çŸ³
            const geometry = new THREE.OctahedronGeometry(6, 0); 
            const material = new THREE.MeshStandardMaterial({
                color: 0xffd700, // é‡‘è‰²
                emissive: 0xffd700, // è‡ªå‘å…‰
                emissiveIntensity: 1.5,
                roughness: 0.1,
                metalness: 0.8
            });
            topStar = new THREE.Mesh(geometry, material);
            topStar.position.set(0, 175, 0); // æ ‘é¡¶
            
            // åŠ ä¸€ä¸ªç‚¹å…‰æºåœ¨æ˜Ÿæ˜Ÿé‡Œï¼Œç…§äº®å‘¨å›´
            const starLight = new THREE.PointLight(0xffd700, 1.0, 100);
            topStar.add(starLight);
            
            scene.add(topStar);
        }

        // --- 4. ç²’å­æ ‘ ---
        function createFluffyTree() {
            const count = 4000;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            const color1 = new THREE.Color(0x0d5c2e); // æ·±æ¾ç»¿
            const color2 = new THREE.Color(0x4dc06b); // äº®ç»¿

            for(let i=0; i<count; i++) {
                const y = Math.random() * 170;
                const progress = 1 - (y / 170);
                const radius = (10 + progress * 65) + (Math.random() - 0.5) * 15; 
                const angle = Math.random() * Math.PI * 2;

                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                positions.push(x, y, z);

                const color = Math.random() > 0.4 ? color1 : color2;
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const spriteMap = createSoftParticleTexture();

            const material = new THREE.PointsMaterial({
                size: 3.5,
                map: spriteMap,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleTree = new THREE.Points(geometry, material);
            scene.add(particleTree);
        }

        // --- 5. Emoji è£…é¥° ---
        function addDecorations() {
            const group = new THREE.Group();
            const count = 450; 

            for (let i = 0; i < count; i++) {
                const emoji = EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
                const map = createEmojiTexture(emoji);
                const material = new THREE.SpriteMaterial({ map: map, transparent: true });
                const sprite = new THREE.Sprite(material);

                const y = Math.random() * 160;
                const progress = 1 - (y / 160);
                const radius = (20 + progress * 60); 
                const angle = Math.random() * Math.PI * 2;

                sprite.position.set(
                    Math.cos(angle) * radius,
                    y + 5,
                    Math.sin(angle) * radius
                );
                
                const scale = 7 + Math.random() * 4;
                sprite.scale.set(scale, scale, 1);
                
                sprite.userData = {
                    offset: Math.random() * 100,
                    speed: 0.02 + Math.random() * 0.02
                };

                group.add(sprite);
            }
            scene.add(group);
            window.decorations = group;
        }

        // --- 6. ç‰©ç†æè´¨ç…§ç‰‡ ---
        function addFeaturedPhotos() {
            const loader = new THREE.TextureLoader();
            
            const configs = [
                { file: imageFiles[0], pos: [-40, 45, 40], rot: [0, Math.PI/4, 0] },
                { file: imageFiles[1], pos: [40, 45, 40], rot: [0, -Math.PI/4, 0] },
                { file: imageFiles[2], pos: [0, 95, 35], rot: [0, 0, 0] }, 
                { file: imageFiles[3], pos: [-35, 125, 0], rot: [0, 0, 0] }, 
                { file: imageFiles[4], pos: [35, 75, -35], rot: [0, Math.PI, 0] } 
            ];

            configs.forEach((cfg) => {
                loader.load(cfg.file, (tex) => {
                    const img = tex.image;
                    const aspect = img.width / img.height;
                    const baseWidth = 22;
                    const baseHeight = baseWidth / aspect;

                    // å…³é”®ä¿®æ”¹ï¼šMeshStandardMaterial
                    // è¿™ä¼šè®©ç…§ç‰‡å—å…‰ç…§å½±å“ï¼Œä¸å†æ˜¯æ­»ç™½çš„
                    const photoMat = new THREE.MeshStandardMaterial({ 
                        map: tex, 
                        side: THREE.DoubleSide,
                        roughness: 0.3,  // æœ‰ä¸€ç‚¹åå…‰
                        metalness: 0.0,
                        emissive: 0xffffff, // è‡ªå‘å…‰é¢œè‰²
                        emissiveMap: tex,   // è‡ªå‘å…‰è´´å›¾
                        emissiveIntensity: 0.2 // å¾®å¼±è‡ªå‘å…‰ï¼Œä¿è¯æš—å¤„å¯è§ï¼Œä½†ä¸å¤§äº®
                    });

                    const photoGeo = new THREE.PlaneGeometry(1, 1);
                    const photo = new THREE.Mesh(photoGeo, photoMat);
                    photo.scale.set(baseWidth, baseHeight, 1);
                    photo.position.z = 0.1;

                    // è¾¹æ¡†æè´¨
                    const borderMat = new THREE.MeshStandardMaterial({ 
                        color: 0xffffff, 
                        roughness: 0.8 
                    });
                    const borderGeo = new THREE.PlaneGeometry(1, 1);
                    const border = new THREE.Mesh(borderGeo, borderMat);
                    
                    const padding = 2;
                    const bottomPadding = 6;
                    border.scale.set(baseWidth + padding*2, baseHeight + padding + bottomPadding, 1);
                    border.position.y = - (bottomPadding - padding) / 2;

                    const card = new THREE.Group();
                    card.add(border);
                    card.add(photo);

                    card.position.set(...cfg.pos);
                    if (cfg.rot) card.rotation.set(...cfg.rot);

                    card.userData = {
                        originalY: cfg.pos[1],
                        offset: Math.random() * 100
                    };

                    window.photoCards.add(card);
                });
            });
        }

        // --- è¾…åŠ©å·¥å…· ---
        function createEmojiTexture(emoji) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = '100px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function createSoftParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            controls.update();

            // è£…é¥°ç‰©æµ®åŠ¨
            if (window.decorations) {
                window.decorations.children.forEach(sprite => {
                    sprite.position.y += Math.sin(time * 2 + sprite.userData.offset) * 0.1;
                });
            }

            // ç…§ç‰‡å¡ç‰‡æµ®åŠ¨
            if (window.photoCards) {
                window.photoCards.children.forEach(card => {
                    card.position.y = card.userData.originalY + Math.sin(time + card.userData.offset) * 0.3;
                    card.lookAt(camera.position); 
                });
            }

            // æ ‘è‡ªè½¬
            if (particleTree) {
                particleTree.rotation.y = time * 0.05;
                if (window.decorations) window.decorations.rotation.y = time * 0.05;
            }

            // æ˜Ÿæ˜Ÿæ—‹è½¬
            if (topStar) {
                topStar.rotation.y -= 0.02;
                topStar.rotation.x = Math.sin(time) * 0.1;
            }
            
            // æ˜Ÿç©ºèƒŒæ™¯ç¼“æ…¢æ—‹è½¬
            if (window.stars) {
                window.stars.rotation.y = time * 0.01;
            }

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>