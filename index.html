<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas, NN!</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Times New Roman', serif;
            /* æ·±é‚ƒæ˜Ÿç©ºèƒŒæ™¯ */
            background: radial-gradient(circle at center bottom, #2b1325 0%, #11081f 50%, #000000 100%);
        }
        
        #ui-container {
            position: absolute; bottom: 30px; width: 100%; text-align: center; 
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 15px;
        }
        
        #greeting {
            font-size: 3.5em; 
            font-weight: 100;
            color: #fff;
            text-shadow: 0 0 10px #ffaa00, 0 0 20px #ff6600, 0 0 40px #ff0000;
            pointer-events: auto;
            margin-bottom: 10px;
            font-style: italic;
            letter-spacing: 2px;
            animation: floatText 3s infinite ease-in-out;
        }
        
        /* æ§åˆ¶æ å®¹å™¨ */
        .controls-row {
            display: flex; gap: 20px; align-items: center;
            pointer-events: auto;
        }

        /* ç»ç’ƒæ‹Ÿæ€æ ·å¼ */
        .glass-panel {
            background: rgba(20, 10, 30, 0.6); 
            padding: 12px 25px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            display: flex; align-items: center; gap: 15px;
            color: #ffccaa; font-size: 1em; 
            border: 1px solid rgba(255, 200, 100, 0.2);
            box-shadow: 0 0 15px rgba(255, 100, 50, 0.2);
            transition: all 0.3s ease;
        }

        /* ä¸Šä¼ æŒ‰é’®æ ·å¼ */
        #uploadBtn {
            cursor: pointer;
            font-family: sans-serif;
            font-weight: bold;
            display: flex; align-items: center; gap: 8px;
        }
        #uploadBtn:hover {
            background: rgba(255, 200, 100, 0.2);
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.4);
            transform: scale(1.05);
        }

        input[type=range] {
            width: 150px; cursor: pointer; accent-color: #ffaa00;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); text-shadow: 0 0 10px #ffaa00, 0 0 20px #ff6600; }
            50% { transform: translateY(-5px); text-shadow: 0 0 15px #ffcc00, 0 0 30px #ff8800; }
        }

        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; justify-content: center; align-items: center;
            color: #ccaa88; font-size: 1.2em; letter-spacing: 2px;
            transition: opacity 1s ease;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/tween.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
</head>
<body>

    <div id="loading">âœ¨ æ­£åœ¨å †é›ªäºº...</div>

    <div id="ui-container">
        <div id="greeting" contenteditable="true">Merry Christmas, shinini!</div>
        
        <div class="controls-row">
            <div class="glass-panel">
                <span>ğŸŒ™</span>
                <input type="range" id="brightnessSlider" min="0.5" max="2.5" step="0.1" value="1.3">
                <span>âœ¨</span>
            </div>

            <div class="glass-panel" id="uploadBtn">
                <span>ğŸ“· æ›´æ¢ç…§ç‰‡</span>
            </div>
            <input type="file" id="fileInput" multiple accept="image/*" style="display: none;">
        </div>
    </div>

    <script>
        // --- 1. é…ç½®åŒºåŸŸ ---
        const imageFiles = ['./1.jpg', './2.jpg', './3.jpg', './4.jpg', './5.jpg']; 
        const EMOJIS = ['ğŸ', 'ğŸ¦Œ', 'ğŸ¬', 'ğŸ””', 'â„ï¸', 'â›„', 'ğŸ„', 'ğŸŒŸ'];

        let scene, camera, renderer, composer, controls;
        let particleTree, lights = [], topStar;
        let bloomPass;
        
        window.photoCards = new THREE.Group();
        window.stars = new THREE.Group();
        window.dustSystem = new THREE.Group();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x1a0b2e, 0.0012); 

            // å…¨æ™¯è§†è§’
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 40, 260);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.LinearToneMapping; 
            renderer.toneMappingExposure = 1.0;
            // å¼€å¯é˜´å½±
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5; 
            controls.maxPolarAngle = Math.PI / 2 - 0.02; 

            // --- ç¯å…‰ç³»ç»Ÿ ---
            const ambientLight = new THREE.AmbientLight(0xccaaee, 0.5); 
            scene.add(ambientLight);
            lights.push(ambientLight);

            const mainLight = new THREE.PointLight(0xffaa00, 2.0, 400); 
            mainLight.position.set(0, 80, 0);
            mainLight.castShadow = true; // ä¸»å…‰äº§ç”Ÿé˜´å½±
            scene.add(mainLight);
            lights.push(mainLight);

            const rimLight = new THREE.DirectionalLight(0x4444ff, 0.8);
            rimLight.position.set(-50, 50, 100);
            scene.add(rimLight);
            lights.push(rimLight);

            // --- åœºæ™¯æ­å»º ---
            createBigStarrySky();
            createFloatingDust();
            createReflectiveGround();
            createFluffyTree();
            createTopStar();
            addDecorations();
            addFeaturedPhotos();

            // --- æ–°å¢ï¼šç¯å¢ƒè§’è‰² ---
            createSnowman(); // 3D é›ªäºº
            createCharacterSprites(); // åœ£è¯è€äººå’Œé©¯é¹¿

            scene.add(window.photoCards);

            // --- åæœŸå¤„ç† ---
            const renderScene = new THREE.RenderPass(scene, camera);
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.3, 0.5, 0.7 
            );
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç§»é™¤ Loading
            const loader = document.getElementById('loading');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 1000);
            
            // --- äº¤äº’äº‹ä»¶ç»‘å®š ---
            setupUIInteractions();

            animate();
        }

        // --- UI äº¤äº’é€»è¾‘ (æ»‘å— + ä¸Šä¼ ) ---
        function setupUIInteractions() {
            // 1. äº®åº¦æ»‘å—
            const slider = document.getElementById('brightnessSlider');
            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                renderer.toneMappingExposure = val * 0.8;
                lights[1].intensity = val * 1.5; // mainLight
                bloomPass.strength = val * 0.9;
                if(topStar) topStar.material.emissiveIntensity = val * 1.5;
            });

            // 2. ç…§ç‰‡ä¸Šä¼ é€»è¾‘
            const uploadBtn = document.getElementById('uploadBtn');
            const fileInput = document.getElementById('fileInput');

            uploadBtn.addEventListener('click', () => {
                // æš‚åœæ—‹è½¬ï¼Œæ–¹ä¾¿çœ‹ç…§ç‰‡
                controls.autoRotate = false;
                fileInput.click();
            });

            fileInput.addEventListener('change', (event) => {
                const files = event.target.files;
                if (files.length > 0) {
                    const cards = window.photoCards.children;
                    // éå†ä¸Šä¼ çš„æ–‡ä»¶ï¼Œé€ä¸ªæ›¿æ¢
                    Array.from(files).forEach((file, index) => {
                        if (index < cards.length) {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                const img = new Image();
                                img.src = e.target.result;
                                img.onload = () => {
                                    // æ›´æ–°è´´å›¾
                                    const texture = new THREE.Texture(img);
                                    texture.needsUpdate = true;
                                    
                                    // æ‰¾åˆ°å½“å‰å¡ç‰‡é‡Œçš„ Photo Mesh (å®ƒæ˜¯ Group çš„ç¬¬ 2 ä¸ªå­å…ƒç´ ï¼Œç´¢å¼• 1)
                                    // ç»“æ„: Group -> [Border(0), Photo(1)]
                                    const cardGroup = cards[index];
                                    const photoMesh = cardGroup.children[1];
                                    const borderMesh = cardGroup.children[0];

                                    // æ›¿æ¢æè´¨è´´å›¾
                                    photoMesh.material.map = texture;
                                    photoMesh.material.emissiveMap = texture;
                                    photoMesh.material.needsUpdate = true;

                                    // é‡æ–°è®¡ç®—æ¯”ä¾‹ (å…³é”®ï¼é˜²æ­¢å˜å½¢)
                                    const aspect = img.width / img.height;
                                    const baseWidth = 22;
                                    const baseHeight = baseWidth / aspect;

                                    // æ›´æ–°ç…§ç‰‡å°ºå¯¸
                                    photoMesh.scale.set(baseWidth, baseHeight, 1);

                                    // æ›´æ–°è¾¹æ¡†å°ºå¯¸
                                    const padding = 2; const bottomPadding = 6;
                                    borderMesh.scale.set(baseWidth + padding*2, baseHeight + padding + bottomPadding, 1);
                                    borderMesh.position.y = - (bottomPadding - padding) / 2;
                                };
                            };
                            reader.readAsDataURL(file);
                        }
                    });
                    
                    // æ¢å¤æ—‹è½¬ (å»¶æ—¶ä¸€ä¸‹)
                    setTimeout(() => { controls.autoRotate = true; }, 5000);
                }
            });
        }

        // --- æ–°å¢åŠŸèƒ½ï¼š3D é›ªäºº (çº¯ä»£ç ç”Ÿæˆ) ---
        function createSnowman() {
            const snowman = new THREE.Group();
            
            // æè´¨ï¼šç™½è‰²ï¼Œç¨å¾®ç²—ç³™ï¼Œåƒé›ª
            const snowMat = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, roughness: 0.8, metalness: 0.1 
            });
            const coalMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const noseMat = new THREE.MeshStandardMaterial({ color: 0xffa500 }); // æ©™è‰²é¼»å­
            
            // 1. èº«ä½“ (åº•åº§)
            const body = new THREE.Mesh(new THREE.SphereGeometry(14, 32, 32), snowMat);
            body.position.y = 10;
            body.castShadow = true; body.receiveShadow = true;
            snowman.add(body);

            // 2. èº«ä½“ (ä¸­é—´)
            const torso = new THREE.Mesh(new THREE.SphereGeometry(10, 32, 32), snowMat);
            torso.position.y = 28;
            torso.castShadow = true; torso.receiveShadow = true;
            snowman.add(torso);

            // 3. å¤´
            const head = new THREE.Mesh(new THREE.SphereGeometry(7, 32, 32), snowMat);
            head.position.y = 42;
            head.castShadow = true; head.receiveShadow = true;
            snowman.add(head);

            // 4. çœ¼ç›
            const eyeGeo = new THREE.SphereGeometry(1, 16, 16);
            const eyeL = new THREE.Mesh(eyeGeo, coalMat);
            eyeL.position.set(-2, 44, 6);
            const eyeR = new THREE.Mesh(eyeGeo, coalMat);
            eyeR.position.set(2, 44, 6);
            snowman.add(eyeL); snowman.add(eyeR);

            // 5. é¼»å­ (åœ†é”¥)
            const noseGeo = new THREE.ConeGeometry(1.5, 6, 32);
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.rotation.x = Math.PI / 2;
            nose.position.set(0, 42, 9);
            snowman.add(nose);

            // 6. çº¢è‰²å›´å·¾
            const scarfMat = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 1.0 });
            const scarf = new THREE.Mesh(new THREE.TorusGeometry(7.5, 1.5, 16, 30), scarfMat);
            scarf.rotation.x = Math.PI / 2;
            scarf.position.set(0, 36, 0);
            snowman.add(scarf);

            // æ”¾ç½®ä½ç½®ï¼šæ ‘çš„å·¦ä¾§
            snowman.position.set(-60, -20, 40);
            snowman.rotation.y = 0.5; // é¢å‘è§‚ä¼—

            scene.add(snowman);
        }

        // --- æ–°å¢åŠŸèƒ½ï¼šç¯å¢ƒè§’è‰² (åœ£è¯è€äºº & é©¯é¹¿) ---
        function createCharacterSprites() {
            // ä½¿ç”¨ Emoji ç»˜åˆ¶å¤§è´´å›¾
            const santaMap = createEmojiTexture('ğŸ…');
            const deerMap = createEmojiTexture('ğŸ¦Œ');

            const santaMat = new THREE.SpriteMaterial({ map: santaMap, transparent: true });
            const deerMat = new THREE.SpriteMaterial({ map: deerMap, transparent: true });

            const santa = new THREE.Sprite(santaMat);
            const deer = new THREE.Sprite(deerMat);

            // è®¾ç½®å¤§å°
            santa.scale.set(40, 40, 1);
            deer.scale.set(35, 35, 1);

            // æ”¾ç½®ä½ç½®ï¼šå³ä¾§å’Œåæ–¹
            santa.position.set(60, 0, 30); // ç¨å¾®ç¦»åœ°ä¸€ç‚¹
            deer.position.set(30, -5, -50); 

            // ç®€å•çš„æµ®åŠ¨åŠ¨ç”» ID
            santa.userData = { id: 'santa' };
            deer.userData = { id: 'deer' };

            scene.add(santa);
            scene.add(deer);
            
            window.characters = [santa, deer];
        }

        // --- æ ¸å¿ƒï¼šæ˜Ÿç©º ---
        function createBigStarrySky() {
            const geometry = new THREE.BufferGeometry();
            const count = 4000; 
            const positions = [];
            const sizes = [];
            
            for(let i=0; i<count; i++) {
                const r = 450 + Math.random() * 500; 
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                positions.push(
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                );
                sizes.push(1.0 + Math.random() * 3.0);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1)); 

            const material = new THREE.PointsMaterial({
                color: 0xffffff, size: 2.5, transparent: true, opacity: 0.9, sizeAttenuation: true 
            });
            const starSystem = new THREE.Points(geometry, material);
            window.stars = starSystem;
            scene.add(starSystem);
        }

        // --- æ‚¬æµ®æ˜Ÿå°˜ ---
        function createFloatingDust() {
            const geometry = new THREE.BufferGeometry();
            const count = 1000;
            const positions = [];
            for(let i=0; i<count; i++) {
                positions.push(
                    (Math.random() - 0.5) * 400,
                    Math.random() * 200,
                    (Math.random() - 0.5) * 400
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xffccaa, size: 1.5, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending
            });
            const dust = new THREE.Points(geometry, material);
            window.dustSystem = dust;
            scene.add(dust);
        }

        // --- åœ°é¢ ---
        function createReflectiveGround() {
            const geometry = new THREE.PlaneGeometry(3000, 3000);
            const material = new THREE.MeshStandardMaterial({
                color: 0x080810, roughness: 0.2, metalness: 0.4
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -20;
            ground.receiveShadow = true; // æ¥æ”¶é˜´å½±
            scene.add(ground);
        }

        // --- æ ‘é¡¶æ˜Ÿ ---
        function createTopStar() {
            const geometry = new THREE.OctahedronGeometry(6, 0); 
            const material = new THREE.MeshStandardMaterial({
                color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 1.5, roughness: 0.1, metalness: 0.8
            });
            topStar = new THREE.Mesh(geometry, material);
            topStar.position.set(0, 175, 0);
            const starLight = new THREE.PointLight(0xffd700, 1.0, 100);
            topStar.add(starLight);
            scene.add(topStar);
        }

        // --- ç²’å­æ ‘ ---
        function createFluffyTree() {
            const count = 4000;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color1 = new THREE.Color(0x0d5c2e);
            const color2 = new THREE.Color(0x4dc06b);

            for(let i=0; i<count; i++) {
                const y = Math.random() * 170;
                const progress = 1 - (y / 170);
                const radius = (10 + progress * 65) + (Math.random() - 0.5) * 15; 
                const angle = Math.random() * Math.PI * 2;
                positions.push(
                    Math.cos(angle) * radius, y, Math.sin(angle) * radius
                );
                const color = Math.random() > 0.4 ? color1 : color2;
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const spriteMap = createSoftParticleTexture();
            const material = new THREE.PointsMaterial({
                size: 3.5, map: spriteMap, vertexColors: true, transparent: true, opacity: 0.9, depthWrite: false, blending: THREE.AdditiveBlending
            });
            particleTree = new THREE.Points(geometry, material);
            scene.add(particleTree);
        }

        // --- è£…é¥° ---
        function addDecorations() {
            const group = new THREE.Group();
            const count = 450; 
            for (let i = 0; i < count; i++) {
                const emoji = EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
                const map = createEmojiTexture(emoji);
                const material = new THREE.SpriteMaterial({ map: map, transparent: true });
                const sprite = new THREE.Sprite(material);
                const y = Math.random() * 160;
                const progress = 1 - (y / 160);
                const radius = (20 + progress * 60); 
                const angle = Math.random() * Math.PI * 2;
                sprite.position.set(Math.cos(angle) * radius, y + 5, Math.sin(angle) * radius);
                const scale = 7 + Math.random() * 4;
                sprite.scale.set(scale, scale, 1);
                sprite.userData = { offset: Math.random() * 100 };
                group.add(sprite);
            }
            scene.add(group);
            window.decorations = group;
        }

        // --- ç…§ç‰‡å¡ç‰‡ ---
        function addFeaturedPhotos() {
            const loader = new THREE.TextureLoader();
            const configs = [
                { file: imageFiles[0], pos: [-40, 45, 40], rot: [0, Math.PI/4, 0] },
                { file: imageFiles[1], pos: [40, 45, 40], rot: [0, -Math.PI/4, 0] },
                { file: imageFiles[2], pos: [0, 95, 35], rot: [0, 0, 0] }, 
                { file: imageFiles[3], pos: [-35, 125, 0], rot: [0, 0, 0] }, 
                { file: imageFiles[4], pos: [35, 75, -35], rot: [0, Math.PI, 0] } 
            ];

            configs.forEach((cfg) => {
                loader.load(cfg.file, (tex) => {
                    const img = tex.image;
                    const aspect = img.width / img.height;
                    const baseWidth = 22;
                    const baseHeight = baseWidth / aspect;

                    const photoMat = new THREE.MeshStandardMaterial({ 
                        map: tex, side: THREE.DoubleSide, roughness: 0.3, metalness: 0.0, emissive: 0xffffff, emissiveMap: tex, emissiveIntensity: 0.2 
                    });
                    const photoGeo = new THREE.PlaneGeometry(1, 1);
                    const photo = new THREE.Mesh(photoGeo, photoMat);
                    photo.scale.set(baseWidth, baseHeight, 1);
                    photo.position.z = 0.1;

                    const borderMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
                    const borderGeo = new THREE.PlaneGeometry(1, 1);
                    const border = new THREE.Mesh(borderGeo, borderMat);
                    const padding = 2; const bottomPadding = 6;
                    border.scale.set(baseWidth + padding*2, baseHeight + padding + bottomPadding, 1);
                    border.position.y = - (bottomPadding - padding) / 2;

                    const card = new THREE.Group();
                    card.add(border);
                    card.add(photo);
                    card.position.set(...cfg.pos);
                    if (cfg.rot) card.rotation.set(...cfg.rot);
                    card.userData = { originalY: cfg.pos[1], offset: Math.random() * 100 };
                    window.photoCards.add(card);
                });
            });
        }

        // --- è¾…åŠ©å·¥å…· ---
        function createEmojiTexture(emoji) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = '100px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function createSoftParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            controls.update();

            if (window.decorations) {
                window.decorations.children.forEach(sprite => {
                    sprite.position.y += Math.sin(time * 2 + sprite.userData.offset) * 0.1;
                });
            }

            if (window.photoCards) {
                window.photoCards.children.forEach(card => {
                    card.position.y = card.userData.originalY + Math.sin(time + card.userData.offset) * 0.3;
                    card.lookAt(camera.position); 
                });
            }

            // è§’è‰²è½»å¾®æµ®åŠ¨
            if (window.characters) {
                window.characters.forEach(char => {
                    char.position.y += Math.sin(time * 1.5) * 0.05;
                });
            }

            if (particleTree) {
                particleTree.rotation.y = time * 0.05;
                if (window.decorations) window.decorations.rotation.y = time * 0.05;
            }

            if (topStar) {
                topStar.rotation.y -= 0.02;
                topStar.rotation.x = Math.sin(time) * 0.1;
            }
            
            if (window.stars) window.stars.rotation.y = time * 0.005;
            if (window.dustSystem) window.dustSystem.rotation.y = -time * 0.01;

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>