<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas, NN!</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Times New Roman', serif;
            /* èƒŒæ™¯è°ƒæ•´ï¼šæ·±é‚ƒçš„æ˜Ÿç©ºç´«é»‘æ¸å˜ */
            background: radial-gradient(circle at center bottom, #2b1325 0%, #11081f 50%, #000000 100%);
        }
        
        #ui-container {
            position: absolute; bottom: 30px; width: 100%; text-align: center; 
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        
        #greeting {
            font-size: 3.5em; 
            font-weight: 100;
            color: #fff;
            text-shadow: 0 0 10px #ffaa00, 0 0 20px #ff6600, 0 0 40px #ff0000;
            pointer-events: auto;
            margin-bottom: 25px;
            font-style: italic;
            letter-spacing: 2px;
            animation: floatText 3s infinite ease-in-out;
        }
        
        #slider-container {
            pointer-events: auto;
            background: rgba(20, 10, 30, 0.6); 
            padding: 12px 25px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            display: flex; align-items: center; gap: 15px;
            color: #ffccaa; font-size: 1em; 
            border: 1px solid rgba(255, 200, 100, 0.2);
            box-shadow: 0 0 15px rgba(255, 100, 50, 0.2);
        }

        input[type=range] {
            width: 180px; cursor: pointer; accent-color: #ffaa00;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); text-shadow: 0 0 10px #ffaa00, 0 0 20px #ff6600; }
            50% { transform: translateY(-5px); text-shadow: 0 0 15px #ffcc00, 0 0 30px #ff8800; }
        }

        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; justify-content: center; align-items: center;
            color: #ccaa88; font-size: 1.2em; letter-spacing: 2px;
            transition: opacity 1s ease;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/libs/tween.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
</head>
<body>

    <div id="loading">âœ¨ æ­£åœ¨ç‚¹äº®æ˜Ÿç©º...</div>

    <div id="ui-container">
        <div id="greeting" contenteditable="true">Merry Christmas, ShiNiNi!</div>
        
        <div id="slider-container">
            <span>ğŸŒ™ é™è°§</span>
            <input type="range" id="brightnessSlider" min="0.5" max="2.5" step="0.1" value="1.3">
            <span>âœ¨ ç’€ç’¨</span>
        </div>
    </div>

    <script>
        // --- 1. é…ç½®åŒºåŸŸ ---
        const imageFiles = ['./1.jpg', './2.jpg', './3.jpg', './4.jpg', './5.jpg']; 
        const EMOJIS = ['ğŸ', 'ğŸ¦Œ', 'ğŸ¬', 'ğŸ””', 'â„ï¸', 'â›„', 'ğŸ„', 'ğŸŒŸ'];

        let scene, camera, renderer, composer, controls;
        let particleTree, lights = [], topStar;
        let bloomPass;
        
        window.photoCards = new THREE.Group();
        window.stars = new THREE.Group();
        window.dustSystem = new THREE.Group(); // æ–°å¢ï¼šæ‚¬æµ®å°˜åŸƒ

        function init() {
            scene = new THREE.Scene();
            // é›¾æ°”ç¨å¾®è°ƒæ·¡ä¸€ç‚¹ç‚¹ï¼Œè®©è¿œå¤„æ˜Ÿæ˜Ÿæ›´æ¸…æ™°
            scene.fog = new THREE.FogExp2(0x1a0b2e, 0.0012); 

            // --- ä¿®æ”¹ï¼šç›¸æœºä½ç½®åˆå§‹åŒ– (å…¨æ™¯è§†è§’) ---
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 3000);
            // åŸæ¥æ˜¯ z=190ï¼Œç°åœ¨æ”¹ä¸º z=260ï¼Œä¸”ç¨å¾®é™ä½ y é«˜åº¦ï¼Œä»°è§†æ„Ÿæ›´å¼º
            camera.position.set(0, 40, 260);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.LinearToneMapping; 
            renderer.toneMappingExposure = 1.0; 
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5; 
            controls.maxPolarAngle = Math.PI / 2 - 0.02; 

            // --- ç¯å…‰ç³»ç»Ÿ ---
            const ambientLight = new THREE.AmbientLight(0xccaaee, 0.5); 
            scene.add(ambientLight);
            lights.push(ambientLight);

            const mainLight = new THREE.PointLight(0xffaa00, 2.0, 400); 
            mainLight.position.set(0, 80, 0);
            scene.add(mainLight);
            lights.push(mainLight);

            const rimLight = new THREE.DirectionalLight(0x4444ff, 0.8);
            rimLight.position.set(-50, 50, 100);
            scene.add(rimLight);
            lights.push(rimLight);

            // --- åœºæ™¯æ­å»º ---
            createBigStarrySky(); // ä¿®æ”¹ï¼šå¤§æ˜Ÿæ˜ŸèƒŒæ™¯
            createFloatingDust(); // æ–°å¢ï¼šè¿‘å¤„æ‚¬æµ®æ˜Ÿå°˜
            createReflectiveGround();
            createFluffyTree();
            createTopStar();
            addDecorations();
            addFeaturedPhotos();
            
            scene.add(window.photoCards);

            // --- åæœŸå¤„ç† ---
            const renderScene = new THREE.RenderPass(scene, camera);
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.3, 0.5, 0.7 
            );
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç§»é™¤ Loading
            const loader = document.getElementById('loading');
            loader.style.opacity = 0;
            setTimeout(() => loader.remove(), 1000);
            
            // æ»‘å—é€»è¾‘
            const slider = document.getElementById('brightnessSlider');
            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                renderer.toneMappingExposure = val * 0.8;
                mainLight.intensity = val * 1.5;
                bloomPass.strength = val * 0.9;
                if(topStar) topStar.material.emissiveIntensity = val * 1.5;
            });

            animate();
        }

        // --- 1. å¢å¼ºç‰ˆï¼šæ˜Ÿç©ºèƒŒæ™¯ (æ˜Ÿæ˜Ÿæ›´å¤§) ---
        function createBigStarrySky() {
            const geometry = new THREE.BufferGeometry();
            const count = 4000; // æ˜Ÿæ˜Ÿæ•°é‡å¢åŠ 
            const positions = [];
            const sizes = [];
            
            for(let i=0; i<count; i++) {
                const r = 450 + Math.random() * 500; 
                const theta = 2 * Math.PI * Math.random();
                const phi = Math.acos(2 * Math.random() - 1);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                
                positions.push(x, y, z);
                
                // å°ºå¯¸éšæœºï¼Œæœ€å¤§å¯è¾¾ 4.0ï¼Œæ¯”ä¹‹å‰å¤§å¾ˆå¤š
                sizes.push(1.0 + Math.random() * 3.0);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1)); // ä¼ å…¥ shader

            // ä½¿ç”¨è‡ªå®šä¹‰æè´¨æ¥å®ç°æ˜Ÿæ˜Ÿå¤§å°å˜åŒ–å’Œé—ªçƒ
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2.5, // åŸºç¡€å¤§å°å˜å¤§
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true // è¿œå°è¿‘å¤§
            });
            
            const starSystem = new THREE.Points(geometry, material);
            window.stars = starSystem;
            scene.add(starSystem);
        }

        // --- æ–°å¢ï¼šæ‚¬æµ®æ˜Ÿå°˜ (ä¸°å¯Œç¯å¢ƒ) ---
        function createFloatingDust() {
            const geometry = new THREE.BufferGeometry();
            const count = 1000;
            const positions = [];
            
            for(let i=0; i<count; i++) {
                // åœ¨æ ‘å‘¨å›´éšæœºåˆ†å¸ƒ
                const x = (Math.random() - 0.5) * 400;
                const y = Math.random() * 200;
                const z = (Math.random() - 0.5) * 400;
                positions.push(x, y, z);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xffccaa, // æš–è‰²å¾®å°˜
                size: 1.5,
                transparent: true,
                opacity: 0.4,
                blending: THREE.AdditiveBlending
            });
            
            const dust = new THREE.Points(geometry, material);
            window.dustSystem = dust;
            scene.add(dust);
        }

        // --- 2. åå…‰åœ°é¢ ---
        function createReflectiveGround() {
            const geometry = new THREE.PlaneGeometry(3000, 3000);
            const material = new THREE.MeshStandardMaterial({
                color: 0x080810, // æ·±è‰²åœ°é¢
                roughness: 0.2,  // éå¸¸å…‰æ»‘ï¼Œåå…‰å¼º
                metalness: 0.4
            });
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -20;
            scene.add(ground);
        }

        // --- 3. æ ‘é¡¶å¤§æ˜Ÿæ˜Ÿ ---
        function createTopStar() {
            const geometry = new THREE.OctahedronGeometry(6, 0); 
            const material = new THREE.MeshStandardMaterial({
                color: 0xffd700, 
                emissive: 0xffd700, 
                emissiveIntensity: 1.5,
                roughness: 0.1,
                metalness: 0.8
            });
            topStar = new THREE.Mesh(geometry, material);
            topStar.position.set(0, 175, 0);
            
            const starLight = new THREE.PointLight(0xffd700, 1.0, 100);
            topStar.add(starLight);
            
            scene.add(topStar);
        }

        // --- 4. ç²’å­æ ‘ ---
        function createFluffyTree() {
            const count = 4000;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color1 = new THREE.Color(0x0d5c2e);
            const color2 = new THREE.Color(0x4dc06b);

            for(let i=0; i<count; i++) {
                const y = Math.random() * 170;
                const progress = 1 - (y / 170);
                const radius = (10 + progress * 65) + (Math.random() - 0.5) * 15; 
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                positions.push(x, y, z);
                const color = Math.random() > 0.4 ? color1 : color2;
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const spriteMap = createSoftParticleTexture();
            const material = new THREE.PointsMaterial({
                size: 3.5,
                map: spriteMap,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleTree = new THREE.Points(geometry, material);
            scene.add(particleTree);
        }

        // --- 5. Emoji è£…é¥° ---
        function addDecorations() {
            const group = new THREE.Group();
            const count = 450; 
            for (let i = 0; i < count; i++) {
                const emoji = EMOJIS[Math.floor(Math.random() * EMOJIS.length)];
                const map = createEmojiTexture(emoji);
                const material = new THREE.SpriteMaterial({ map: map, transparent: true });
                const sprite = new THREE.Sprite(material);
                const y = Math.random() * 160;
                const progress = 1 - (y / 160);
                const radius = (20 + progress * 60); 
                const angle = Math.random() * Math.PI * 2;
                sprite.position.set(Math.cos(angle) * radius, y + 5, Math.sin(angle) * radius);
                const scale = 7 + Math.random() * 4;
                sprite.scale.set(scale, scale, 1);
                sprite.userData = { offset: Math.random() * 100 };
                group.add(sprite);
            }
            scene.add(group);
            window.decorations = group;
        }

        // --- 6. ç‰©ç†æè´¨ç…§ç‰‡ ---
        function addFeaturedPhotos() {
            const loader = new THREE.TextureLoader();
            const configs = [
                { file: imageFiles[0], pos: [-40, 45, 40], rot: [0, Math.PI/4, 0] },
                { file: imageFiles[1], pos: [40, 45, 40], rot: [0, -Math.PI/4, 0] },
                { file: imageFiles[2], pos: [0, 95, 35], rot: [0, 0, 0] }, 
                { file: imageFiles[3], pos: [-35, 125, 0], rot: [0, 0, 0] }, 
                { file: imageFiles[4], pos: [35, 75, -35], rot: [0, Math.PI, 0] } 
            ];

            configs.forEach((cfg) => {
                loader.load(cfg.file, (tex) => {
                    const img = tex.image;
                    const aspect = img.width / img.height;
                    const baseWidth = 22;
                    const baseHeight = baseWidth / aspect;

                    const photoMat = new THREE.MeshStandardMaterial({ 
                        map: tex, 
                        side: THREE.DoubleSide,
                        roughness: 0.3, 
                        metalness: 0.0,
                        emissive: 0xffffff,
                        emissiveMap: tex,
                        emissiveIntensity: 0.2 
                    });

                    const photoGeo = new THREE.PlaneGeometry(1, 1);
                    const photo = new THREE.Mesh(photoGeo, photoMat);
                    photo.scale.set(baseWidth, baseHeight, 1);
                    photo.position.z = 0.1;

                    const borderMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
                    const borderGeo = new THREE.PlaneGeometry(1, 1);
                    const border = new THREE.Mesh(borderGeo, borderMat);
                    const padding = 2; const bottomPadding = 6;
                    border.scale.set(baseWidth + padding*2, baseHeight + padding + bottomPadding, 1);
                    border.position.y = - (bottomPadding - padding) / 2;

                    const card = new THREE.Group();
                    card.add(border);
                    card.add(photo);
                    card.position.set(...cfg.pos);
                    if (cfg.rot) card.rotation.set(...cfg.rot);
                    card.userData = { originalY: cfg.pos[1], offset: Math.random() * 100 };
                    window.photoCards.add(card);
                });
            });
        }

        // --- è¾…åŠ©å·¥å…· ---
        function createEmojiTexture(emoji) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = '100px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emoji, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function createSoftParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            controls.update();

            if (window.decorations) {
                window.decorations.children.forEach(sprite => {
                    sprite.position.y += Math.sin(time * 2 + sprite.userData.offset) * 0.1;
                });
            }

            if (window.photoCards) {
                window.photoCards.children.forEach(card => {
                    card.position.y = card.userData.originalY + Math.sin(time + card.userData.offset) * 0.3;
                    card.lookAt(camera.position); 
                });
            }

            if (particleTree) {
                particleTree.rotation.y = time * 0.05;
                if (window.decorations) window.decorations.rotation.y = time * 0.05;
            }

            if (topStar) {
                topStar.rotation.y -= 0.02;
                topStar.rotation.x = Math.sin(time) * 0.1;
            }
            
            // èƒŒæ™¯æ˜Ÿç©ºç¼“æ…¢æ—‹è½¬
            if (window.stars) window.stars.rotation.y = time * 0.005;
            // æ‚¬æµ®å¾®å°˜ç¼“æ…¢æµåŠ¨
            if (window.dustSystem) window.dustSystem.rotation.y = -time * 0.01;

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>